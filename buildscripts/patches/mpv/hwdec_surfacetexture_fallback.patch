--- a/video/out/hwdec/hwdec_aimagereader.c
+++ b/video/out/hwdec/hwdec_aimagereader.c
@@ -20,7 +20,10 @@
 #include <assert.h>
 #include <pthread.h>
 #include <dlfcn.h>
+#include <unistd.h>
 #include <EGL/egl.h>
+#include <GLES2/gl2.h>
+#include <GLES2/gl2ext.h>
 #include <media/NdkImageReader.h>
 #include <android/native_window_jni.h>
 #include <libavcodec/mediacodec.h>
@@ -42,6 +45,17 @@
     jobject surface;
     void *lib_handle;
 
+    // SurfaceTexture fallback (used when AImageReader symbols are missing)
+    bool use_surfacetexture;
+    jobject surfaceTexture;       // android.graphics.SurfaceTexture (global ref)
+    GLuint st_gl_texture;         // GL_TEXTURE_EXTERNAL_OES for SurfaceTexture
+    jclass stClass;               // cached class ref
+    jmethodID stUpdateTexImage;
+    jmethodID stGetTimestamp;
+    jmethodID stGetTransformMatrix;
+    jmethodID stRelease;
+    jmethodID surfaceRelease;
+
     media_status_t (*AImageReader_newWithUsage)(
         int32_t, int32_t, int32_t, uint64_t, int32_t, AImageReader **);
     media_status_t (*AImageReader_getWindow)(
@@ -73,6 +87,8 @@
     EGLClientBuffer (EGLAPIENTRY *GetNativeClientBufferANDROID)(
         const struct AHardwareBuffer *);
     void (EGLAPIENTRY *EGLImageTargetTexture2DOES)(GLenum, GLeglImageOES);
+
+    // (SurfaceTexture uses direct OES path — no FBO/shader state needed)
 };
 
 const static struct { const char *symbol; int offset; } lib_functions[] = {
@@ -125,6 +141,121 @@
     return true;
 }
 
+// --- SurfaceTexture fallback for devices missing AImageReader symbols ---
+// Direct OES path: SurfaceTexture's OES texture is exposed directly to MPV.
+// No FBO blit, no custom shaders — MPV handles the OES texture via its
+// own shader pipeline (with GL_OES_EGL_image_external sampler).
+
+static bool init_surfacetexture(struct ra_hwdec *hw)
+{
+    struct priv_owner *p = hw->priv;
+    GL *gl = ra_gl_get(hw->ra_ctx->ra);
+    JNIEnv *env = MP_JNI_GET_ENV(hw);
+    if (!env)
+        return false;
+
+    // Create OES texture for SurfaceTexture
+    gl->GenTextures(1, &p->st_gl_texture);
+    gl->BindTexture(GL_TEXTURE_EXTERNAL_OES, p->st_gl_texture);
+    gl->TexParameteri(GL_TEXTURE_EXTERNAL_OES, GL_TEXTURE_MIN_FILTER, GL_LINEAR);
+    gl->TexParameteri(GL_TEXTURE_EXTERNAL_OES, GL_TEXTURE_MAG_FILTER, GL_LINEAR);
+    gl->TexParameteri(GL_TEXTURE_EXTERNAL_OES, GL_TEXTURE_WRAP_S, GL_CLAMP_TO_EDGE);
+    gl->TexParameteri(GL_TEXTURE_EXTERNAL_OES, GL_TEXTURE_WRAP_T, GL_CLAMP_TO_EDGE);
+    gl->BindTexture(GL_TEXTURE_EXTERNAL_OES, 0);
+
+    // Find SurfaceTexture class and methods
+    jclass stClass = (*env)->FindClass(env, "android/graphics/SurfaceTexture");
+    if (!stClass) {
+        MP_ERR(hw, "SurfaceTexture class not found\n");
+        return false;
+    }
+    p->stClass = (*env)->NewGlobalRef(env, stClass);
+
+    jmethodID stCtor = (*env)->GetMethodID(env, stClass, "<init>", "(I)V");
+    p->stUpdateTexImage = (*env)->GetMethodID(env, stClass, "updateTexImage", "()V");
+    p->stGetTimestamp = (*env)->GetMethodID(env, stClass, "getTimestamp", "()J");
+    p->stGetTransformMatrix = (*env)->GetMethodID(env, stClass,
+        "getTransformMatrix", "([F)V");
+    p->stRelease = (*env)->GetMethodID(env, stClass, "release", "()V");
+    if (!stCtor || !p->stUpdateTexImage || !p->stGetTimestamp ||
+        !p->stGetTransformMatrix || !p->stRelease) {
+        MP_ERR(hw, "SurfaceTexture methods not found\n");
+        return false;
+    }
+
+    // Find Surface class and methods
+    jclass surfaceClass = (*env)->FindClass(env, "android/view/Surface");
+    if (!surfaceClass) {
+        MP_ERR(hw, "Surface class not found\n");
+        return false;
+    }
+    jmethodID surfaceCtor = (*env)->GetMethodID(env, surfaceClass, "<init>",
+        "(Landroid/graphics/SurfaceTexture;)V");
+    p->surfaceRelease = (*env)->GetMethodID(env, surfaceClass, "release", "()V");
+    if (!surfaceCtor || !p->surfaceRelease) {
+        MP_ERR(hw, "Surface methods not found\n");
+        return false;
+    }
+
+    // Create SurfaceTexture(texName)
+    jobject st = (*env)->NewObject(env, stClass, stCtor, (jint)p->st_gl_texture);
+    if (!st || (*env)->ExceptionCheck(env)) {
+        (*env)->ExceptionClear(env);
+        MP_ERR(hw, "Failed to create SurfaceTexture\n");
+        return false;
+    }
+    p->surfaceTexture = (*env)->NewGlobalRef(env, st);
+    (*env)->DeleteLocalRef(env, st);
+
+    // Create Surface(surfaceTexture)
+    jobject surface = (*env)->NewObject(env, surfaceClass, surfaceCtor,
+                                        p->surfaceTexture);
+    if (!surface || (*env)->ExceptionCheck(env)) {
+        (*env)->ExceptionClear(env);
+        MP_ERR(hw, "Failed to create Surface from SurfaceTexture\n");
+        return false;
+    }
+    p->surface = (*env)->NewGlobalRef(env, surface);
+    (*env)->DeleteLocalRef(env, surface);
+    (*env)->DeleteLocalRef(env, stClass);
+    (*env)->DeleteLocalRef(env, surfaceClass);
+
+    MP_INFO(hw, "SurfaceTexture fallback initialized, direct OES path (texture=%u)\n",
+            p->st_gl_texture);
+    return true;
+}
+
+static void uninit_surfacetexture(struct ra_hwdec *hw)
+{
+    struct priv_owner *p = hw->priv;
+    JNIEnv *env = MP_JNI_GET_ENV(hw);
+    GL *gl = ra_gl_get(hw->ra_ctx->ra);
+
+    if (env) {
+        if (p->surface) {
+            (*env)->CallVoidMethod(env, p->surface, p->surfaceRelease);
+            (*env)->DeleteGlobalRef(env, p->surface);
+            p->surface = NULL;
+        }
+        if (p->surfaceTexture) {
+            (*env)->CallVoidMethod(env, p->surfaceTexture, p->stRelease);
+            (*env)->DeleteGlobalRef(env, p->surfaceTexture);
+            p->surfaceTexture = NULL;
+        }
+        if (p->stClass) {
+            (*env)->DeleteGlobalRef(env, (jobject)p->stClass);
+            p->stClass = NULL;
+        }
+    }
+
+    if (p->st_gl_texture) {
+        gl->DeleteTextures(1, &p->st_gl_texture);
+        p->st_gl_texture = 0;
+    }
+}
+
+// --- Main hwdec callbacks ---
+
 static int init(struct ra_hwdec *hw)
 {
     struct priv_owner *p = hw->priv;
@@ -138,8 +269,7 @@
     if (!gl_check_extension(exts, "EGL_ANDROID_image_native_buffer"))
         return -1;
 
-    if (!load_lib_functions(p, hw->log))
-        return -1;
+    bool aimagereader_ok = load_lib_functions(p, hw->log);
 
     static const char *es2_exts[] = {"GL_OES_EGL_image_external", 0};
     static const char *es3_exts[] = {"GL_OES_EGL_image_external_essl3", 0};
@@ -149,29 +279,37 @@
     else
         hw->glsl_extensions = es2_exts;
 
-    // dummy dimensions, AImageReader only transports hardware buffers
-    media_status_t ret = p->AImageReader_newWithUsage(16, 16,
-        AIMAGE_FORMAT_PRIVATE, AHARDWAREBUFFER_USAGE_GPU_SAMPLED_IMAGE,
-        5, &p->reader);
-    if (ret != AMEDIA_OK) {
-        MP_ERR(hw, "newWithUsage failed: %d\n", ret);
-        return -1;
-    }
-    assert(p->reader);
+    if (aimagereader_ok) {
+        // Normal AImageReader path
+        media_status_t ret = p->AImageReader_newWithUsage(16, 16,
+            AIMAGE_FORMAT_PRIVATE, AHARDWAREBUFFER_USAGE_GPU_SAMPLED_IMAGE,
+            5, &p->reader);
+        if (ret != AMEDIA_OK) {
+            MP_ERR(hw, "newWithUsage failed: %d\n", ret);
+            return -1;
+        }
+        assert(p->reader);
 
-    ANativeWindow *window;
-    ret = p->AImageReader_getWindow(p->reader, &window);
-    if (ret != AMEDIA_OK) {
-        MP_ERR(hw, "getWindow failed: %d\n", ret);
-        return -1;
-    }
-    assert(window);
+        ANativeWindow *window;
+        ret = p->AImageReader_getWindow(p->reader, &window);
+        if (ret != AMEDIA_OK) {
+            MP_ERR(hw, "getWindow failed: %d\n", ret);
+            return -1;
+        }
+        assert(window);
 
-    JNIEnv *env = MP_JNI_GET_ENV(hw);
-    assert(env);
-    jobject surface = p->ANativeWindow_toSurface(env, window);
-    p->surface = (*env)->NewGlobalRef(env, surface);
-    (*env)->DeleteLocalRef(env, surface);
+        JNIEnv *env = MP_JNI_GET_ENV(hw);
+        assert(env);
+        jobject surface = p->ANativeWindow_toSurface(env, window);
+        p->surface = (*env)->NewGlobalRef(env, surface);
+        (*env)->DeleteLocalRef(env, surface);
+    } else {
+        // SurfaceTexture fallback for Fire OS and similar
+        MP_INFO(hw, "AImageReader symbols incomplete, using SurfaceTexture fallback\n");
+        if (!init_surfacetexture(hw))
+            return -1;
+        p->use_surfacetexture = true;
+    }
 
     p->hwctx = (struct mp_hwdec_ctx) {
         .driver_name = hw->driver->name,
@@ -192,17 +330,22 @@
 static void uninit(struct ra_hwdec *hw)
 {
     struct priv_owner *p = hw->priv;
-    JNIEnv *env = MP_JNI_GET_ENV(hw);
-    assert(env);
 
-    if (p->surface) {
-        (*env)->DeleteGlobalRef(env, p->surface);
-        p->surface = NULL;
-    }
+    if (p->use_surfacetexture) {
+        uninit_surfacetexture(hw);
+    } else {
+        JNIEnv *env = MP_JNI_GET_ENV(hw);
+        assert(env);
+
+        if (p->surface) {
+            (*env)->DeleteGlobalRef(env, p->surface);
+            p->surface = NULL;
+        }
 
-    if (p->reader) {
-        p->AImageReader_delete(p->reader);
-        p->reader = NULL;
+        if (p->reader) {
+            p->AImageReader_delete(p->reader);
+            p->reader = NULL;
+        }
     }
 
     hwdec_devices_remove(hw->devs, &p->hwctx);
@@ -228,9 +371,42 @@
 {
     struct priv *p = mapper->priv;
     struct priv_owner *o = mapper->owner->priv;
-    GL *gl = ra_gl_get(mapper->ra);
 
     p->log = mapper->log;
+
+    if (o->use_surfacetexture) {
+        // SurfaceTexture path: expose OES texture directly to MPV.
+        // No FBO blit — MPV handles the OES texture via its shader pipeline,
+        // just like the AImageReader path. This eliminates the extra GPU
+        // render pass that was causing frame drops on Fire TV.
+        mapper->dst_params = mapper->src_params;
+        mapper->dst_params.imgfmt = IMGFMT_RGB0;
+        mapper->dst_params.hw_subfmt = 0;
+
+        struct ra_tex_params params = {
+            .dimensions = 2,
+            .w = mapper->src_params.w,
+            .h = mapper->src_params.h,
+            .d = 1,
+            .format = ra_find_unorm_format(mapper->ra, 1, 4),
+            .render_src = true,
+            .src_linear = true,
+            .external_oes = true,   // OES texture directly, no FBO blit
+        };
+        if (params.format->ctype != RA_CTYPE_UNORM)
+            return -1;
+
+        mapper->tex[0] = ra_create_wrapped_tex(mapper->ra, &params,
+                                               o->st_gl_texture);
+        if (!mapper->tex[0])
+            return -1;
+
+        MP_INFO(mapper, "SurfaceTexture direct OES path (no FBO blit)\n");
+        return 0;
+    }
+
+    // Normal AImageReader path
+    GL *gl = ra_gl_get(mapper->ra);
     pthread_mutex_init(&p->lock, NULL);
     pthread_cond_init(&p->cond, NULL);
 
@@ -289,8 +465,13 @@
 {
     struct priv *p = mapper->priv;
     struct priv_owner *o = mapper->owner->priv;
-    GL *gl = ra_gl_get(mapper->ra);
 
+    if (o->use_surfacetexture) {
+        ra_tex_free(mapper->ra, &mapper->tex[0]);
+        return;
+    }
+
+    GL *gl = ra_gl_get(mapper->ra);
     o->AImageReader_setImageListener(o->reader, NULL);
 
     gl->DeleteTextures(1, &p->gl_texture);
@@ -307,6 +488,9 @@
     struct priv *p = mapper->priv;
     struct priv_owner *o = mapper->owner->priv;
 
+    if (o->use_surfacetexture)
+        return; // FBO texture content persists until next map
+
     if (p->egl_image) {
         p->DestroyImageKHR(eglGetCurrentDisplay(), p->egl_image);
         p->egl_image = 0;
@@ -324,6 +508,32 @@
     struct priv_owner *o = mapper->owner->priv;
     GL *gl = ra_gl_get(mapper->ra);
 
+    if (o->use_surfacetexture) {
+        // --- SurfaceTexture direct OES path (no FBO blit) ---
+        if (mapper->src->imgfmt != IMGFMT_MEDIACODEC)
+            return -1;
+        AVMediaCodecBuffer *buffer = (AVMediaCodecBuffer *)mapper->src->planes[3];
+
+        JNIEnv *env = MP_JNI_GET_ENV(mapper);
+        if (!env)
+            return -1;
+
+        // Release decoded buffer to the Surface (renders the frame)
+        av_mediacodec_release_buffer(buffer, 1);
+
+        // Latch the latest frame onto the OES texture.
+        // MPV will sample from this texture directly via its shader pipeline.
+        (*env)->CallVoidMethod(env, o->surfaceTexture, o->stUpdateTexImage);
+        if ((*env)->ExceptionCheck(env)) {
+            (*env)->ExceptionClear(env);
+            MP_WARN(mapper, "updateTexImage failed\n");
+            return -1;
+        }
+
+        return 0;
+    }
+
+    // --- Normal AImageReader path ---
     {
         if (mapper->src->imgfmt != IMGFMT_MEDIACODEC)
             return -1;
